const { cleanupConfig } = require('./cleanup')
const { logObject, logSubHeader } = require('./logger')
const { cleanupConfigOpts } = require('./options')

// Log options in debug mode.
const logOpts = function(opts, { logs, debug, cachedConfig }) {
  // In production, print those in the first call to `@netlify/config`, not the
  // second one done inside `@netlify/build`
  if (!debug || cachedConfig !== undefined) {
    return
  }

<<<<<<< HEAD
  logSubHeader('Initial build settings')
  logObject(cleanupConfigOpts(opts))
=======
  logSubHeader(logs, '@netlify/config options')
  logObject(logs, cleanupConfigOpts(opts))
>>>>>>> Add `buffer` option to `@netlify/config`
}

// Log `defaultConfig` option in debug mode
const logDefaultConfig = function(defaultConfig, { logs, debug }) {
  if (!debug || defaultConfig === undefined) {
    return
  }

<<<<<<< HEAD
  logSubHeader('UI build settings')
  logObject(cleanupConfig(defaultConfig))
=======
  logSubHeader(logs, '@netlify/config defaultConfig')
  logObject(logs, cleanupConfig(defaultConfig))
>>>>>>> Add `buffer` option to `@netlify/config`
}

// Log return value of `@netlify/config` in debug mode
const logResult = function({ configPath, buildDir, config, context, branch }, { logs, debug }) {
  if (!debug) {
    return
  }

<<<<<<< HEAD
  logSubHeader('Resolved build settings')
  logObject({ configPath, buildDir, context, branch })

  logSubHeader('Resolved config')
  logObject(cleanupConfig(config))
=======
  logSubHeader(logs, '@netlify/config result')
  logObject(logs, { configPath, buildDir, config: cleanupConfig(config), context, branch })
>>>>>>> Add `buffer` option to `@netlify/config`
}

module.exports = { logOpts, logDefaultConfig, logResult }
